<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TXT â†’ FB2 è±ªåè½¬æ¢å™¨</title>
<meta name="color-scheme" content="light dark">
<style>
:root{
  --bg: #f2f4f7; --card: #ffffffd9; --text: #222; --accent: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
  --shadow: 0 8px 32px #0000001a; --radius: 16px;
}
@media (prefers-color-scheme:dark){
:root{ --bg: #121212; --card: #1e1e1ed9; --text: #eee; }
}
*{
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
}
body{
  background: var(--bg);
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 1rem;
}
.container{
  width: 100%;
  max-width: 520px;
  background: var(--card);
  backdrop-filter: blur(10px);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 2rem;
}
h1{
  font-size: 1.5rem;
  margin-bottom: .5rem;
  text-align: center;
}
p.sub{
  font-size: .9rem;
  opacity: .7;
  text-align: center;
  margin-bottom: 1.5rem;
}
input[type=file]{
  display: none;
}
label.file{
  display: block;
  padding: .8rem 1.2rem;
  border-radius: 8px;
  background: var(--accent);
  color: #fff;
  text-align: center;
  cursor: pointer;
  transition: transform .2s;
}
label.file:hover{
  transform: translateY(-2px);
}
.buttons{
  display: flex;
  gap: .8rem;
  margin-top: 1.2rem;
}
button{
  flex: 1;
  padding: .7rem;
  font-size: 1rem;
  border: none;
  border-radius: 8px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  transition: opacity .2s;
}
button:disabled{
  opacity: .5;
  cursor: not-allowed;
}
#log{
  margin-top: 1.2rem;
  font-size: .85rem;
  max-height: 30vh;
  overflow: auto;
  white-space: pre-wrap;
  background: #00000008;
  padding: .8rem;
  border-radius: 8px;
}
/* åŠ è½½åŠ¨ç”» */
.loading{
  display: inline-block;
  width: 1rem;
  height: 1rem;
  border: 2px solid #fff;
  border-bottom-color: transparent;
  border-radius: 50%;
  animation: spin .6s linear infinite;
}
@keyframes spin{
  to{
    transform: rotate(360deg);
  }
}
</style>
</head>
<body>
<div class="container">
  <h1>ğŸ“– TXT â†’ FB2 è±ªåè½¬æ¢å™¨</h1>
  <p class="sub">æ”¯æŒ GB18030/GBK/UTF-8ï¼Œæ™ºèƒ½è¯†åˆ« å·/ç« /ç•ªå¤–/åºç« /Extra</p>

  <input type="file" id="pick" accept=".txt">
  <label for="pick" class="file">é€‰æ‹© TXT æ–‡ä»¶</label>

  <div class="buttons">
    <button id="dl" disabled>ä¸‹è½½ *.fb2</button>
    <button id="cp" disabled>å¤åˆ¶ XML</button>
  </div>

  <div id="log">ç­‰å¾…é€‰æ‹©æ–‡ä»¶â€¦</div>
</div>

<script>
/* ================= è§£ç  ================= */
function decodeText(buf) {
  const uints = new Uint8Array(buf);
  try {
    return new TextDecoder('gb18030', {fatal: true}).decode(uints);
  } catch (e) {
    try {
      return new TextDecoder('gbk', {fatal: true}).decode(uints);
    } catch (e2) {
      return new TextDecoder('utf-8', {fatal: true}).decode(uints);
    }
  }
}

/* ================= ç« èŠ‚è¯†åˆ«ï¼ˆå«ç•ªå¤–/å·/åº/ç»ˆ/Extraï¼‰ ================= */

/* ================= ä¿®æ­£åçš„ç« èŠ‚è¯†åˆ« ================= */
const CHAPTER_RE = [
  /^\s*(ç¬¬\s*[\dã€‡é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+\s*[å·ç¯‡ç« èŠ‚å›é›†éƒ¨]\s*[\s\S]*)$/im,
  /^\s*(ç•ªå¤–|å¤–ä¼ |Extra|Bonus|åºç« |ç»ˆç« |åè®°|å‰è¨€|åºè¨€|é™„å½•)\s*[\-â€”:]?\s*([\s\S]*)$/im,
  /^\s*(?:Chapter|Chap\.?)\s+[\dã€‡é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+\s*[\-â€”:]?\s*([\s\S]*)$/im,
  /^\s*[\dã€‡é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+\s*[ã€.\s]\s*([\s\S]+)$/im
];

function parseChapters(raw) {
  const lines = raw.replace(/\r\n/g, '\n').split('\n');
  const chapters = [];
  let cur = {title: '', lines: []};

  const push = () => {
    if (cur.title || cur.lines.length) {
      cur.title = cur.title.trim();
      cur.text = cur.lines.join('\n').trim();
      if (cur.text) chapters.push(cur);
    }
    cur = {title: '', lines: []};
  };

  for (let line of lines) {
    let hit = false;
    for (let re of CHAPTER_RE) {
      if (re.test(line)) {
        // å…³é”®é™åˆ¶ï¼šæ ‡é¢˜éƒ¨åˆ†ï¼ˆå»æ‰é¦–å°¾ç©ºç™½ï¼‰è¶…è¿‡20ä¸ªæ±‰å­— â†’ ä¸ç®—ç« èŠ‚
        const titlePart = line.trim();
        // åªç»Ÿè®¡æ±‰å­—ï¼Œç”¨ Unicode èŒƒå›´ç²—ç•¥åŒ¹é…
        const hanCount = (titlePart.match(/[\u4e00-\u9fa5]/g) || []).length;
        if (hanCount <= 20) {
          hit = true;
          break;
        }
      }
    }
    if (hit) { push(); cur.title = line.trim(); }
    else cur.lines.push(line);
  }
  push();
  return chapters;
}



/* ================= å…ƒæ•°æ® ================= */

/* ---------- æå–ä¹¦åï¼šå…ˆæ–‡ä»¶åï¼Œå†æ–‡ä»¶å†…å®¹ ---------- */

function guessMeta(chapters, fullText, fileName) {
  let bookName = 'æœªçŸ¥ä¹¦å', author = 'æœªçŸ¥ä½œè€…';

  /* 1. ä¹¦åï¼šä¼˜å…ˆæ–‡ä»¶åé‡Œçš„ã€Šã€‹ */
  const fnMatch = fileName.match(/ã€Š([^ã€Šã€‹]+)ã€‹/);
  if (fnMatch) bookName = fnMatch[1];

  /* 2. ä½œè€…ï¼šæ–‡ä»¶åé‡Œåˆ° [ æˆ– ã€ ç»“æŸ */
  /* ä½œè€…ï¼šåˆ°æ¢è¡Œç»“æŸï¼ˆä¸å«æ¢è¡Œï¼‰ */
const fnAuthMatch = fileName.match(/ä½œè€…[:ï¼š]\s*([^\[ã€\r\n]+)/);
if (fnAuthMatch) {
  author = fnAuthMatch[1].trim();
} else {
  const txtAuthMatch = fullText.slice(0, 600).match(/ä½œè€…[:ï¼š]\s*([^\r\n]+)/);
  if (txtAuthMatch) {
    const rawAuth = txtAuthMatch[1].trim();
    const hanCount = (rawAuth.match(/[\u4e00-\u9fa5]/g) || []).length;
    author = hanCount <= 20 ? rawAuth : 'æœªçŸ¥ä½œè€…';
  }
}


  /* 4. ä¹¦åå›é€€ï¼šæ­£æ–‡æœ€å‰ 800 å­—æ‰¾ã€Šã€‹ */
  if (!fnMatch) {
    const txtMatch = fullText.slice(0, 800).match(/ã€Š([^ã€Šã€‹]+)ã€‹/);
    if (txtMatch) bookName = txtMatch[1];
  }

  /* 5. æç«¯å›é€€ï¼šç”¨ç¬¬ä¸€ç« æ ‡é¢˜ */
  if (bookName === 'æœªçŸ¥ä¹¦å' && chapters[0]?.title) bookName = chapters[0].title;

  return {bookName, author};
}



/* ================= ç”Ÿæˆ FB2 ================= */
function buildFB2(chapters, meta) {
  const {bookName, author} =meta;
  const annotation = chapters[0] ? chapters[0].text.slice(0, 500) + 'â€¦' : '';
  let body = '';
  chapters.forEach(ch => {
    body += `<section><title><p>${escapeXml(ch.title || 'æ— é¢˜')}</p></title>\n`;
    body += `<p>${escapeXml(ch.text).split('\n').join('</p>\n<p>')}</p>\n`;
    body += `</section>\n`;
  });
  return `<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
<description>
  <title-info>
    <genre>sf</genre>
    <author><last-name>${escapeXml(author)}</last-name></author>
    <book-title>${escapeXml(bookName)}</book-title>
    <annotation><p>${escapeXml(annotation)}</p></annotation>
    <lang>zh</lang>
    <src-lang>zh</src-lang>
  </title-info>
  <document-info>
    <author><nickname>txt2fb2</nickname></author>
    <date>${new Date().toISOString().slice(0,10)}</date>
    <id>${generateUUID()}</id>
    <version>1.0</version>
  </document-info>
</description>
<body>${body}</body>
</FictionBook>`;
}

/* ================= å°å·¥å…· ================= */
function escapeXml(s) {
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&apos;'}[c]));
}
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
    return v.toString(16);
  });
}

/* ================= UI äº¤äº’ ================= */
const pick = document.getElementById('pick');
const dl  = document.getElementById('dl');
const cp  = document.getElementById('cp');
const log = document.getElementById('log');
let lastXML = '';

let baseName = 'book';
let fullFileName = 'book.txt';   // æ–°å¢ï¼šå­˜å®Œæ•´åŸåï¼ˆå«æ‰©å±•åï¼‰
pick.addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file) return;
  dl.disabled = cp.disabled = true;
  log.innerHTML = '<span class="loading"></span> æ­£åœ¨è§£ç å¹¶è§£æç« èŠ‚â€¦';

  baseName     = file.name.replace(/\.[^.]+$/i, '');
  fullFileName = file.name;                    // ä¿å­˜å®Œæ•´åŸå
  if (baseName.length > 200) baseName = baseName.slice(0, 200);

  const buf  = await file.arrayBuffer();
  const text = decodeText(buf);
  const meta = guessMeta([], text, file.name);
  const chapters = parseChapters(text);
  lastXML = buildFB2(chapters, meta);

  /* æ›´æ–°æŒ‰é’®æ–‡å­—ï¼šå±•ç¤ºå®Œæ•´æ–‡ä»¶åï¼ˆå«æ‰©å±•åï¼‰ */

dl.textContent = 'ä¸‹è½½FB2æ–‡ä»¶';
  /* dl.textContent = 'ä¸‹è½½ ' + fullFileName + ' çš„ FB2 ç‰ˆ'; */

  log.innerHTML = `âœ… è§£æå®Œæˆï¼å…± ${chapters.length} ç« ã€‚\nä¹¦åï¼šã€Š${meta.bookName}ã€‹ ä½œè€…ï¼š${meta.author}`;
  dl.disabled = cp.disabled = false;
});



dl.addEventListener('click', () => {
  const blob = new Blob([lastXML], {type: 'application/fb2+xml'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = baseName + '.fb2';   // â‘¢ è¿™é‡Œç”¨åŸå§‹æ–‡ä»¶å
  a.click();
});


cp.addEventListener('click', () => {
  navigator.clipboard.writeText(lastXML).then(() => {
    log.innerHTML += '\nğŸ“‹ XML å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼';
  });
});
</script>
</body>
</html>
